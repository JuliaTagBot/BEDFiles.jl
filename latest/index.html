<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BEDFiles.jl · BEDFiles</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BEDFiles</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">BEDFiles.jl</a><ul class="internal"><li><a class="toctext" href="#Background-1">Background</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Loading-a-.bed-file-1">Loading a .bed file</a></li><li><a class="toctext" href="#Raw-summaries-1">Raw summaries</a></li><li><a class="toctext" href="#Instantiating-as-a-count-of-the-second-allele-1">Instantiating as a count of the second allele</a></li><li><a class="toctext" href="#Location-of-the-missing-values-1">Location of the missing values</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">BEDFiles.jl</a></li></ul><a class="edit-page" href="https://github.com/dmbates/BEDFiles.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>BEDFiles.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BEDFiles.jl-1" href="#BEDFiles.jl-1">BEDFiles.jl</a></h1><p>Routines for reading and manipulating GWAS data in .bed files</p><h2><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h2><p>Data from <a href="https://en.wikipedia.org/wiki/Genome-wide_association_study"><em>Genome-wide association studies</em></a> are often saved as a <a href="https://www.cog-genomics.org/plink2/formats#bed"><strong>PLINK binary biallelic genotype table</strong></a> or <code>.bed</code> file. To be useful, such files should be accompanied by a <code>.fam</code> file, containing metadata on the rows of the table, and a <code>.bim</code> file, containing metadata on the columns. The <code>.fam</code> and <code>.bim</code> files are in tab-separated format.</p><p>The table contains the observed allelic type at <code>n</code> <a href="https://en.wikipedia.org/wiki/Single-nucleotide_polymorphism"><em>single-nucleotide polymorphism</em></a> (SNP) positions  for <code>m</code> individuals.</p><p>A SNP corresponds to a nucleotide position on the genome where some degree of variation has been observed in a population, with each individual have one of two possible <em>alleles</em> at that position on each of a pair of chromosomes. The three possible types that can be observed are: homozygous allele 1, coded as <code>0x00</code>, heterzygous, coded as <code>0x10</code>, and homozygous allele 2, coded as <code>0x11</code>. Missing values are coded as <code>0x01</code>.</p><p>A single column - one SNP position over all <code>m</code> individuals - is packed into an array of <code>div(m + 3, 4)</code> bytes (<code>UInt8</code> values).</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>This package requires Julia v0.7.0 or later, which can be obtained from <a href="https://julialang.org/downloads/">https://julialang.org/downloads/</a> or by building Julia from the sources in the <a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a> repository.</p><p>The package has not yet been registered and must be installed using the repository location. Start julia and use the <code>]</code> key to switch to the package manager REPL</p><pre><code class="language-julia">(v0.7) pkg&gt; add https://github.com/dmbates/BEDFiles.jl.git#master
  Updating git-repo `https://github.com/dmbates/BEDFiles.jl.git`
  Updating registry at `~/.julia/registries/Uncurated`
  Updating git-repo `https://github.com/JuliaRegistries/Uncurated.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [6f44c9a6] + BEDFiles v0.1.0 #master (https://github.com/dmbates/BEDFiles.jl.git)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [6f44c9a6] + BEDFiles v0.1.0 #master (https://github.com/dmbates/BEDFiles.jl.git)
  [6fe1bfb0] + OffsetArrays v0.6.0
  [10745b16] + Statistics </code></pre><p>Use the backspace key to return to the Julia REPL.</p><h2><a class="nav-anchor" id="Loading-a-.bed-file-1" href="#Loading-a-.bed-file-1">Loading a .bed file</a></h2><p>The <code>BEDFile</code> struct contains the read-only, memory-mapped <code>.bed</code> file as a <code>Matrix{UInt8}</code>, along with <code>m</code>, the number of individuals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEDFiles.BEDFile" href="#BEDFiles.BEDFile"><code>BEDFiles.BEDFile</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BEDFile</code></pre><p>Raw .bed file as a shared, memory-mapped Matrix{UInt8}.  The number of rows, <code>m</code> is stored separately because it is not uniquely determined by the size of the <code>data</code> field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/dmbates/BEDFiles.jl/blob/06ca3f25c29a86c85d10e7a0d5b6133738f42d0e/src/bedfile.jl#L1-L6">source</a></section><p>For convenience, two <code>Int</code> matrices, <code>columncounts</code> and <code>rowcounts</code> are allocated but not populated until used.</p><p>The columns correspond to SNP positions. Rows of the internal matrix are packed values from groups of 4 individuals.</p><pre><code class="language-julia">julia&gt; using BenchmarkTools, BEDFiles

julia&gt; const bf = BEDFile(BEDFiles.datadir(&quot;mouse.bed&quot;));

julia&gt; size(bf)      # the virtual size of the GWAS data - 1940 observations at each of 10150 SNP positions
(1940, 10150)

julia&gt; size(bf.data) # the actual size of the memory-mapped matrix of UInt8s
(485, 10150)</code></pre><p>As described above, a column, consisting of <code>m</code> values in the range <code>0x00</code> to <code>0x03</code>, is packed into <code>div(m + 3, 4)</code> bytes.</p><p>(The calculation <code>div(i + 3, 4)</code> or <code>(i + 3) ÷ 4</code> occurs in some important loops in the code where it is evaluated as the equivalent, but somewhat faster, expression <code>(i + 3) &gt;&gt; 2</code> that performs the integer division by 4 via shifting the number two bits to the right.)</p><p>The virtual number of rows, <code>m</code>, can be given as a second argument in the call to <code>BEDFile</code>. If omitted, <code>m</code> is determined as the number of lines in the <code>.fam</code> file. </p><p>Because the file is memory-mapped this operation is fast, even for very large <code>.bed</code> files.</p><pre><code class="language-julia">julia&gt; @benchmark(BEDFile(BEDFiles.datadir(&quot;mouse.bed&quot;)))
BenchmarkTools.Trial: 
  memory estimate:  390.42 KiB
  allocs estimate:  82
  --------------
  minimum time:     127.349 μs (0.00% GC)
  median time:      135.760 μs (0.00% GC)
  mean time:        150.356 μs (7.05% GC)
  maximum time:     41.823 ms (99.33% GC)
  --------------
  samples:          10000
  evals/sample:     1</code></pre><p>This file, from a study published in 2006, is about 5 Mb in size but data from recent studies, which have samples from tens of thousands of individuals at over a million SNP positions, would be in the tens or even hundreds of Gb range.</p><h2><a class="nav-anchor" id="Raw-summaries-1" href="#Raw-summaries-1">Raw summaries</a></h2><p>Counts of each the four possible values for each column are returned by <code>counts</code>.</p><pre><code class="language-julia">julia&gt; counts(bf, dims=1)
4×10150 Array{Int64,2}:
  358   359  252   358    33   359    33  186   360  …    53    56    56    56    56    56    56    56
    2     0    4     3     4     1     4    1     3      171   174   173   173   162   173   174   175
 1003  1004  888  1004   442  1004   481  803  1002      186   242   242   242   242   242   242   242
  577   577  796   575  1461   576  1422  950   575     1530  1468  1469  1469  1480  1469  1468  1467</code></pre><p>Column 2 has no missing values (code <code>0x01</code>, the second row in the column-counts table). In that SNP position for this sample, 359 indivduals are homozygous allele 1 (<code>G</code> according to the <code>.bim</code> file), 1004 are heterozygous, and 577 are homozygous allele 2 (<code>A</code>).</p><p>The counts by column and by row are cached in the <code>BEDFile</code> object. Accesses after the first are extremely fast.</p><pre><code class="language-julia">julia&gt; @benchmark counts($bf, dims=1)
BenchmarkTools.Trial: 
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     5.115 ns (0.00% GC)
  median time:      5.298 ns (0.00% GC)
  mean time:        5.244 ns (0.00% GC)
  maximum time:     23.231 ns (0.00% GC)
  --------------
  samples:          10000
  evals/sample:     1000</code></pre><h2><a class="nav-anchor" id="Instantiating-as-a-count-of-the-second-allele-1" href="#Instantiating-as-a-count-of-the-second-allele-1">Instantiating as a count of the second allele</a></h2><p>In some operations on GWAS data the data are converted to counts of the second allele, according to</p><table><tr><th>BEDFile</th><th>count</th></tr><tr><td>0x00</td><td>0</td></tr><tr><td>0x01</td><td>missing</td></tr><tr><td>0x10</td><td>1</td></tr><tr><td>0x11</td><td>2</td></tr></table><p>This can be accomplished by indexing <code>bedvals</code></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEDFiles.bedvals" href="#BEDFiles.bedvals"><code>BEDFiles.bedvals</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">BEDvals</code></pre><p><code>Vector{Union{UInt8,Missing}}</code> of the possible values in a BEDFile</p></div></div><a class="source-link" target="_blank" href="https://github.com/dmbates/BEDFiles.jl/blob/06ca3f25c29a86c85d10e7a0d5b6133738f42d0e/src/BEDFiles.jl#L12-L16">source</a></section><p>with the <code>BEDFile</code> or with a view of the <code>BEDFile</code>, producing an array of type <code>Union{Missing,Int8}</code>, which is the preferred way in v0.7 of representing arrays that may contain missing values.</p><pre><code class="language-julia">julia&gt; bedvals[bf]
1940×10150 Array{Union{Missing, Int8},2}:
 1  1  1  1  2  1  2  1  1  1  1  2  1  1  2  …  2         2         2       
 1  1  2  1  1  1  1  2  1  1  1  1  2  2  1     2         2         2       
 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2     2         2         2       
 1  1  1  1  1  1  1  2  1  1  1  1  2  2  1     2         2         2       
 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2     1         1         1       
 1  1  1  1  2  1  2  1  1  1  1  2  1  1  2  …  2         2         2       
 1  1  1  1  2  1  2  1  1  1  1  2  1  1  2     2         2         2       
 1  1  2  1  1  1  1  2  1  1  1  1  2  2  1     2         2         2       
 1  1  2  1  1  1  1  2  1  1  1  1  2  2  1     2         2         2       
 ⋮              ⋮              ⋮              ⋱                              
 1  1  1  1  2  1  2  1  1  1  1  2  1  1  2     2         2         2       
 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2     2         2         2       
 1  1  1  1  2  1  2  1  1  1  1  2  1  1  2     2         2         2       
 2  2  2  2  2  2  2  2  2  2  2  2  2  2  2     2         2         2       
 1  1  1  1  2  1  2  1  1  1  1  2  1  1  2  …  2         2         2       
 1  1  2  1  1  1  1  2  1  1  1  1  2  2  1     2         2         2       
 1  1  2  1  1  1  1  2  1  1  1  1  2  2  1     2         2         2       
 1  1  1  1  1  1  1  2  1  1  1  1  2  2  1      missing   missing   missing
 0  0  0  0  2  0  2  0  0  0  0  2  0  0  2     2         2         2       

julia&gt; sort(unique(ans))
4-element Array{Union{Missing, Int8},1}:
 0       
 1       
 2       
  missing</code></pre><h3><a class="nav-anchor" id="Summary-statistics-1" href="#Summary-statistics-1">Summary statistics</a></h3><p>The package provides methods for the generics <code>mean</code> and <code>var</code> from the <code>Statistics</code> package.</p><pre><code class="language-julia">julia&gt; mean(bf, dims=1)
1×10150 Array{Float64,2}:
 1.113  1.11237  1.28099  1.11203  …  1.8009  1.79966  1.79955  1.79943

julia&gt; var(bf, dims=1)
1×10150 Array{Float64,2}:
 0.469929  0.470089  0.462605  0.469365  …  0.223714  0.223818  0.223923</code></pre><p>These methods make use of the cached column or row counts and thus are very fast</p><pre><code class="language-julia">julia&gt; @benchmark mean(bf, dims=1)
BenchmarkTools.Trial: 
  memory estimate:  79.39 KiB
  allocs estimate:  2
  --------------
  minimum time:     37.777 μs (0.00% GC)
  median time:      38.186 μs (0.00% GC)
  mean time:        45.207 μs (14.53% GC)
  maximum time:     43.815 ms (99.83% GC)
  --------------
  samples:          10000
  evals/sample:     1</code></pre><p>The column-wise or row-wise standard deviations are returned by <code>std</code>.</p><pre><code class="language-julia">julia&gt; std(bf, dims=2)
1940×1 Array{Float64,2}:
 0.6504997290784408
 0.6379008244533891
 0.6558172726141286
 0.6532675479248437
 0.6744432174014563
 0.6519092298111158
 0.6779881845456428
 0.6955814098050999
 0.6437566832989493
 ⋮                 
 0.6613451651895259
 0.6659810347614777
 0.6274577846909379
 0.6823658517777204
 0.6695299551061924
 0.710756592739754 
 0.6387913736114869
 0.6736492722732016
 0.688855476425891 </code></pre><h2><a class="nav-anchor" id="Location-of-the-missing-values-1" href="#Location-of-the-missing-values-1">Location of the missing values</a></h2><p>The positions of the missing data are evaluated by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BEDFiles.missingpos" href="#BEDFiles.missingpos"><code>BEDFiles.missingpos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">missingpos(f::BEDFile)</code></pre><p>Return a <code>SparseMatrixCSC{Bool,Int32}</code> of the same size as <code>f</code> indicating the positions with missing data</p></div></div><a class="source-link" target="_blank" href="https://github.com/dmbates/BEDFiles.jl/blob/06ca3f25c29a86c85d10e7a0d5b6133738f42d0e/src/bedfile.jl#L169-L173">source</a></section><pre><code class="language-julia">julia&gt; mp = missingpos(bf)
1940×10150 SparseArrays.SparseMatrixCSC{Bool,Int32} with 33922 stored entries:
  [702  ,     1]  =  true
  [949  ,     1]  =  true
  [914  ,     3]  =  true
  [949  ,     3]  =  true
  [1604 ,     3]  =  true
  [1891 ,     3]  =  true
  [81   ,     4]  =  true
  [990  ,     4]  =  true
  [1882 ,     4]  =  true
  ⋮
  [1848 , 10150]  =  true
  [1851 , 10150]  =  true
  [1853 , 10150]  =  true
  [1860 , 10150]  =  true
  [1873 , 10150]  =  true
  [1886 , 10150]  =  true
  [1894 , 10150]  =  true
  [1897 , 10150]  =  true
  [1939 , 10150]  =  true
julia&gt; @benchmark missingpos($bf)
BenchmarkTools.Trial: 
  memory estimate:  1.81 MiB
  allocs estimate:  19273
  --------------
  minimum time:     38.009 ms (0.00% GC)
  median time:      38.161 ms (0.00% GC)
  mean time:        38.761 ms (1.25% GC)
  maximum time:     80.250 ms (52.34% GC)
  --------------
  samples:          129
  evals/sample:     1</code></pre><p>So, for example, the number of missing data values in each column can be evaluated as</p><pre><code class="language-julia">julia&gt; sum(mp, dims=1)
1×10150 Array{Int64,2}:
 2  0  4  3  4  1  4  1  3  3  0  4  0  …  174  173  173  162  173  174  175</code></pre><p>although it is faster, but somewhat more obscure, to use</p><pre><code class="language-none">julia&gt; view(counts(bf, dims=1), 2:2, :)
1×10150 view(::Array{Int64,2}, 2:2, :) with eltype Int64:
 2  0  4  3  4  1  4  1  3  3  0  4  0  …  174  173  173  162  173  174  175</code></pre><footer><hr/></footer></article></body></html>
